(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PinchSlider"] = factory();
	else
		root["PinchSlider"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = {}

/* styles */
__webpack_require__(3)

/* script */
__vue_exports__ = __webpack_require__(4)

/* template */
var __vue_template__ = __webpack_require__(2)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "/Users/huangdong/Documents/workspace/pinch-slider/src/pinch-slider.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b2c10f7a", __vue_options__)
  } else {
    hotAPI.reload("data-v-b2c10f7a", __vue_options__)
  }
})()}
if (__vue_options__.functional) {console.error("[vue-loader] pinch-slider.vue: functional components are not supported and should be defined in plain js files using render functions.")}

module.exports = __vue_exports__


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


/* transformjs
 * By dntzhang
 * Github: https://github.com/AlloyTeam/AlloyTouch/tree/master/transformjs
 */
;(function () {

    var Matrix3D = function Matrix3D(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        this.elements = window.Float32Array ? new Float32Array(16) : [];
        var te = this.elements;
        te[0] = n11 !== undefined ? n11 : 1;te[4] = n12 || 0;te[8] = n13 || 0;te[12] = n14 || 0;
        te[1] = n21 || 0;te[5] = n22 !== undefined ? n22 : 1;te[9] = n23 || 0;te[13] = n24 || 0;
        te[2] = n31 || 0;te[6] = n32 || 0;te[10] = n33 !== undefined ? n33 : 1;te[14] = n34 || 0;
        te[3] = n41 || 0;te[7] = n42 || 0;te[11] = n43 || 0;te[15] = n44 !== undefined ? n44 : 1;
    };

    Matrix3D.DEG_TO_RAD = Math.PI / 180;

    Matrix3D.prototype = {
        set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;
            te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;
            te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;
            te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;
            return this;
        },
        identity: function identity() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        },
        multiplyMatrices: function multiplyMatrices(a, be) {

            var ae = a.elements;
            var te = this.elements;
            var a11 = ae[0],
                a12 = ae[4],
                a13 = ae[8],
                a14 = ae[12];
            var a21 = ae[1],
                a22 = ae[5],
                a23 = ae[9],
                a24 = ae[13];
            var a31 = ae[2],
                a32 = ae[6],
                a33 = ae[10],
                a34 = ae[14];
            var a41 = ae[3],
                a42 = ae[7],
                a43 = ae[11],
                a44 = ae[15];

            var b11 = be[0],
                b12 = be[1],
                b13 = be[2],
                b14 = be[3];
            var b21 = be[4],
                b22 = be[5],
                b23 = be[6],
                b24 = be[7];
            var b31 = be[8],
                b32 = be[9],
                b33 = be[10],
                b34 = be[11];
            var b41 = be[12],
                b42 = be[13],
                b43 = be[14],
                b44 = be[15];

            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

            return this;
        },
        // 解决角度为90的整数倍导致Math.cos得到极小的数，其实是0。导致不渲染
        _rounded: function _rounded(value, i) {
            i = Math.pow(10, i || 15);
            // default
            return Math.round(value * i) / i;
        },
        appendTransform: function appendTransform(x, y, z, scaleX, scaleY, scaleZ, rotateX, rotateY, rotateZ, skewX, skewY, originX, originY, originZ) {

            var rx = rotateX * Matrix3D.DEG_TO_RAD;
            var cosx = this._rounded(Math.cos(rx));
            var sinx = this._rounded(Math.sin(rx));
            var ry = rotateY * Matrix3D.DEG_TO_RAD;
            var cosy = this._rounded(Math.cos(ry));
            var siny = this._rounded(Math.sin(ry));
            var rz = rotateZ * Matrix3D.DEG_TO_RAD;
            var cosz = this._rounded(Math.cos(rz * -1));
            var sinz = this._rounded(Math.sin(rz * -1));

            this.multiplyMatrices(this, [1, 0, 0, x, 0, cosx, sinx, y, 0, -sinx, cosx, z, 0, 0, 0, 1]);

            this.multiplyMatrices(this, [cosy, 0, siny, 0, 0, 1, 0, 0, -siny, 0, cosy, 0, 0, 0, 0, 1]);

            this.multiplyMatrices(this, [cosz * scaleX, sinz * scaleY, 0, 0, -sinz * scaleX, cosz * scaleY, 0, 0, 0, 0, 1 * scaleZ, 0, 0, 0, 0, 1]);

            if (skewX || skewY) {
                this.multiplyMatrices(this, [this._rounded(Math.cos(skewX * Matrix3D.DEG_TO_RAD)), this._rounded(Math.sin(skewX * Matrix3D.DEG_TO_RAD)), 0, 0, -1 * this._rounded(Math.sin(skewY * Matrix3D.DEG_TO_RAD)), this._rounded(Math.cos(skewY * Matrix3D.DEG_TO_RAD)), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }

            if (originX || originY || originZ) {
                this.elements[12] -= originX * this.elements[0] + originY * this.elements[4] + originZ * this.elements[8];
                this.elements[13] -= originX * this.elements[1] + originY * this.elements[5] + originZ * this.elements[9];
                this.elements[14] -= originX * this.elements[2] + originY * this.elements[6] + originZ * this.elements[10];
            }
            return this;
        }
    };

    function observe(target, props, callback) {
        for (var i = 0, len = props.length; i < len; i++) {
            var prop = props[i];
            watch(target, prop, callback);
        }
    }

    function watch(target, prop, callback) {
        Object.defineProperty(target, prop, {
            get: function get() {
                return this["__" + prop];
            },
            set: function set(value) {
                if (value !== this["__" + prop]) {
                    this["__" + prop] = value;
                    callback();
                }
            }
        });
    }

    window.Transform = function (element, notPerspective) {

        observe(element, ["translateX", "translateY", "translateZ", "scaleX", "scaleY", "scaleZ", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "originX", "originY", "originZ"], function () {
            var mtx = element.matrix3D.identity().appendTransform(element.translateX, element.translateY, element.translateZ, element.scaleX, element.scaleY, element.scaleZ, element.rotateX, element.rotateY, element.rotateZ, element.skewX, element.skewY, element.originX, element.originY, element.originZ);
            element.style.transform = element.style.msTransform = element.style.OTransform = element.style.MozTransform = element.style.webkitTransform = (notPerspective ? "" : "perspective(" + (element.perspective === undefined ? 500 : element.perspective) + "px) ") + "matrix3d(" + Array.prototype.slice.call(mtx.elements).join(",") + ")";
        });

        element.matrix3D = new Matrix3D();

        if (!notPerspective) {
            observe(element, ["perspective"], function () {
                element.style.transform = element.style.msTransform = element.style.OTransform = element.style.MozTransform = element.style.webkitTransform = "perspective(" + element.perspective + "px) matrix3d(" + Array.prototype.slice.call(element.matrix3D.elements).join(",") + ")";
            });
            element.perspective = 500;
        }

        element.scaleX = element.scaleY = element.scaleZ = 1;
        //由于image自带了x\y\z，所有加上translate前缀
        element.translateX = element.translateY = element.translateZ = element.rotateX = element.rotateY = element.rotateZ = element.skewX = element.skewY = element.originX = element.originY = element.originZ = 0;
    };
})();

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    directives: [{
      name: "finger",
      rawName: "v-finger:swipe",
      value: (_vm.swipe),
      expression: "swipe",
      arg: "swipe"
    }, {
      name: "finger",
      rawName: "v-finger:touch-move",
      value: (_vm.touchMove),
      expression: "touchMove",
      arg: "touch-move"
    }],
    staticClass: "ps-slider"
  }, _vm._l((_vm.slides), function(slide, index) {
    return _c('div', {
      staticClass: "ps-img-wrapper"
    }, [_c('img', {
      directives: [{
        name: "finger",
        rawName: "v-finger:multipoint-start",
        value: (_vm.multipointStart),
        expression: "multipointStart",
        arg: "multipoint-start"
      }, {
        name: "finger",
        rawName: "v-finger:multipoint-end",
        value: (_vm.multipointEnd),
        expression: "multipointEnd",
        arg: "multipoint-end"
      }, {
        name: "finger",
        rawName: "v-finger:pinch",
        value: (_vm.pinch),
        expression: "pinch",
        arg: "pinch"
      }, {
        name: "finger",
        rawName: "v-finger:swipe.stop.prevent",
        value: (_vm.imageSwipe),
        expression: "imageSwipe",
        arg: "swipe",
        modifiers: {
          "stop": true,
          "prevent": true
        }
      }, {
        name: "finger",
        rawName: "v-finger:press-move",
        value: (_vm.pressMove),
        expression: "pressMove",
        arg: "press-move"
      }, {
        name: "finger",
        rawName: "v-finger:double-tap",
        value: (_vm.doubleTap),
        expression: "doubleTap",
        arg: "double-tap"
      }, {
        name: "finger",
        rawName: "v-finger:single-tap",
        value: (_vm.singleTap),
        expression: "singleTap",
        arg: "single-tap"
      }],
      on: {
        "click": _vm.click
      }
    })])
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-b2c10f7a", module.exports)
  }
}

/***/ },
/* 3 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _alloy_finger = __webpack_require__(5);

var _alloy_finger2 = _interopRequireDefault(_alloy_finger);

var _alloy_fingerVue = __webpack_require__(6);

var _alloy_fingerVue2 = _interopRequireDefault(_alloy_fingerVue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//To.js
//a requestAmimation based animation function
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var lastTime = 0;
var vendors = ['webkit', 'moz'];
for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
        callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
};

if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
};

var To = function To(el, property, value, time, ease, onEnd, onChange) {
    var current = el[property];
    var dv = value - current;
    var beginTime = new Date();
    var self = this;
    var currentEase = ease || function (a) {
        return a;
    };
    this.tickID = null;
    var toTick = function toTick() {
        var dt = new Date() - beginTime;
        if (dt >= time) {
            el[property] = value;
            onChange && onChange(value);
            onEnd && onEnd(value);
            cancelAnimationFrame(self.tickID);
            self.toTick = null;
            return;
        }
        el[property] = dv * currentEase(dt / time) + current;
        self.tickID = requestAnimationFrame(toTick);
        onChange && onChange(el[property]);
    };
    toTick();
    To.List.push(this);
};

To.List = [];

To.stopAll = function () {
    for (var i = 0, len = To.List.length; i < len; i++) {
        cancelAnimationFrame(To.List[i].tickID);
    }
    To.List.length = 0;
};

To.stop = function (to) {
    cancelAnimationFrame(to.tickID);
};

function ease(x) {
    return Math.sqrt(1 - Math.pow(x - 1, 2));
}
//To.js end

//component begin
Vue.use(_alloy_fingerVue2.default, { AlloyFinger: _alloy_finger2.default }); // use AlloyFinger's plugin

exports.default = {
    name: 'pinch-slider',
    props: {
        'slides': Array,
        'srcAtr': {
            type: String,
            default: 'src'
        },
        'enablePinch': {
            type: Boolean,
            default: true
        },
        'currentIndex': {
            type: Number,
            default: 0
        },
        'lazyLoad': {
            type: Boolean,
            default: false
        }
    },

    data: function data() {
        return {
            currentScale: 1,
            slidesDoms: [],
            curSlideImg: {},
            lastIndex: -100,
            allImgLoaded: false
        };
    },

    watch: {
        'slides': function slides() {
            this.bindTransform();
        },
        'currentIndex': function currentIndex() {
            this.processCurrentIndexChange();
        }
    },

    mounted: function mounted() {
        this.bindTransform();
    },

    methods: {
        bindTransform: function bindTransform() {
            this.allImgLoaded = false;
            if (this.slides.length > 0 && !this.$el.translateX) {
                Transform(this.$el);
                setTimeout(function () {
                    this.slidesDoms = [].slice.call(this.$el.children);

                    this.slidesDoms.map(function (child, index) {
                        var $img = child.childNodes[0];
                        Transform($img);
                    });
                    this.curSlideImg = this.slidesDoms[this.currentIndex].childNodes[0];

                    this.$emit('on-slide-change', { id: this.$el.id, index: this.currentIndex, slides: this.slides });
                    this.processCurrentIndexChange();
                }.bind(this), 0);
            }
        },

        processCurrentIndexChange: function processCurrentIndexChange() {
            if (this.currentIndex < 0) return;

            //lazyLoad
            this._lazyLoad();

            this.curSlideImg = this.slidesDoms[this.currentIndex].childNodes[0];
            this.curSlideImg.scaleX = this.curSlideImg.scaleY = 1;
            this.curSlideImg.translateX = 0;

            var width = this.$el.clientWidth;
            if (this.lastIndex === this.currentIndex - 1 || this.lastIndex === this.currentIndex + 1) {
                new To(this.$el, 'translateX', -width * this.currentIndex, 500, ease, function () {});
            } else {
                new To(this.$el, 'translateX', -width * this.currentIndex, 0, ease, function () {});
            }

            this.$emit('on-slide-change', { index: this.currentIndex, slides: this.slides });
            this.lastIndex = this.currentIndex;
        },

        _lazyLoad: function _lazyLoad() {
            var _this = this;

            if (!this.allImgLoaded) {
                var allLoaded = true;
                this.slidesDoms.map(function (child, index) {
                    var $img = child.childNodes[0];
                    if (!_this.lazyLoad) {
                        $img.setAttribute('src', _this.slides[index][_this.srcAtr]);
                    } else {
                        allLoaded = false;
                        if (!$img.getAttribute('src') && _this.currentIndex - 1 <= index && _this.currentIndex + 1 >= index) {
                            $img.setAttribute('src', _this.slides[index][_this.srcAtr]);
                        }
                    }
                });
                this.allImgLoaded = allLoaded;
            }
        },

        multipointStart: function multipointStart(evt) {
            this.curSlideImg = this.slidesDoms[this.currentIndex].childNodes[0];
            this.currentScale = this.curSlideImg.scaleX;
            evt.cancelBubble = true;
        },

        swipe: function swipe(evt) {
            if (this.currentScale > 1) {
                return;
            }
            if (evt.direction === 'Left') {
                if (this.currentIndex < this.slides.length - 1) {
                    this.currentIndex++;
                }
            } else if (evt.direction === 'Right') {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                }
            }
        },

        imageSwipe: function imageSwipe(evt) {
            evt.cancelBubble = true;
            evt.preventDefault();
        },

        pinch: function pinch(evt) {
            if (!this.enablePinch) {
                return;
            }

            this.curSlideImg.translateX = 0;
            if (this.currentScale * evt.scale < 1) {
                this.curSlideImg.scaleX = this.curSlideImg.scaleY = 1;
            } else {
                this.curSlideImg.scaleX = this.curSlideImg.scaleY = this.currentScale * evt.scale;
            }
            evt.cancelBubble = true;
            evt.preventDefault();
        },

        pressMove: function pressMove(evt) {
            var range = (this.currentScale - 1) / 2 * this.$el.clientWidth;
            if (this.curSlideImg.translateX + evt.deltaX > range || this.curSlideImg.translateX + evt.deltaX < -range) {
                this.curSlideImg.scaleX = this.curSlideImg.scaleY = 1;
                this.curSlideImg.translateX = 0;
                return;
            } else {
                this.curSlideImg.translateX += evt.deltaX;
            }
        },

        multipointEnd: function multipointEnd() {
            this.currentScale = this.curSlideImg.scaleX;
        },

        doubleTap: function doubleTap() {
            if (!this.enablePinch) {
                return;
            }
            if (this.curSlideImg.scaleX == 1) {
                new To(this.curSlideImg, 'scaleX', 2, 200, ease, function () {});
                new To(this.curSlideImg, 'scaleY', 2, 200, ease, function () {});
                new To(this.curSlideImg, 'translateX', 0, 200, ease, function () {});
                this.currentScale = 2;
            } else {
                new To(this.curSlideImg, 'scaleX', 1, 200, ease, function () {});
                new To(this.curSlideImg, 'scaleY', 1, 200, ease, function () {});
                new To(this.curSlideImg, 'translateX', 0, 200, ease, function () {});
                this.currentScale = 1;
            }
        },

        singleTap: function singleTap(evt) {
            evt.cancelBubble = true;
            evt.preventDefault();
            this.$emit('on-img-tap');
        },

        click: function click(evt) {
            this.$emit('on-img-click');
            evt.cancelBubble = true;
            evt.preventDefault();
        },

        touchMove: function touchMove(evt) {
            if (Math.abs(evt.deltaX) >= Math.abs(evt.deltaY)) {
                evt.preventDefault();
            }
        }
    }
};

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* AlloyFinger v0.1.3
 * By dntzhang
 * Github: https://github.com/AlloyTeam/AlloyFinger
 */
;(function () {
    function getLen(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
    }

    function dot(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }

    function getAngle(v1, v2) {
        var mr = getLen(v1) * getLen(v2);
        if (mr === 0) return 0;
        var r = dot(v1, v2) / mr;
        if (r > 1) r = 1;
        return Math.acos(r);
    }

    function cross(v1, v2) {
        return v1.x * v2.y - v2.x * v1.y;
    }

    function getRotateAngle(v1, v2) {
        var angle = getAngle(v1, v2);
        if (cross(v1, v2) > 0) {
            angle *= -1;
        }

        return angle * 180 / Math.PI;
    }

    var HandlerAdmin = function HandlerAdmin(el) {
        this.handlers = [];
        this.el = el;
    };

    HandlerAdmin.prototype.add = function (handler) {
        this.handlers.push(handler);
    };

    HandlerAdmin.prototype.del = function (handler) {
        for (var i = this.handlers.length; i >= 0; i--) {
            if (this.handlers[i] === handler) {
                this.handlers.splice(i, 1);
            }
        }
    };

    HandlerAdmin.prototype.dispatch = function () {
        for (var i = 0, len = this.handlers.length; i < len; i++) {
            this.handlers[i].apply(this.el, arguments);
        }
    };

    function wrapFunc(el, handler) {
        var handlerAdmin = new HandlerAdmin(el);
        handlerAdmin.add(handler);

        return handlerAdmin;
    }

    var AlloyFinger = function AlloyFinger(el, option) {

        this.element = typeof el == 'string' ? document.querySelector(el) : el;

        this.element.addEventListener("touchstart", this.start.bind(this), false);
        this.element.addEventListener("touchmove", this.move.bind(this), false);
        this.element.addEventListener("touchend", this.end.bind(this), false);
        this.element.addEventListener("touchcancel", this.cancel.bind(this), false);

        this.preV = { x: null, y: null };
        this.pinchStartLen = null;
        this.scale = 1;
        this.isDoubleTap = false;

        var noop = function noop() {};

        this.rotate = wrapFunc(this.element, option.rotate || noop);
        this.touchStart = wrapFunc(this.element, option.touchStart || noop);
        this.multipointStart = wrapFunc(this.element, option.multipointStart || noop);
        this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop);
        this.pinch = wrapFunc(this.element, option.pinch || noop);
        this.swipe = wrapFunc(this.element, option.swipe || noop);
        this.tap = wrapFunc(this.element, option.tap || noop);
        this.doubleTap = wrapFunc(this.element, option.doubleTap || noop);
        this.longTap = wrapFunc(this.element, option.longTap || noop);
        this.singleTap = wrapFunc(this.element, option.singleTap || noop);
        this.pressMove = wrapFunc(this.element, option.pressMove || noop);
        this.touchMove = wrapFunc(this.element, option.touchMove || noop);
        this.touchEnd = wrapFunc(this.element, option.touchEnd || noop);
        this.touchCancel = wrapFunc(this.element, option.touchCancel || noop);

        this.delta = null;
        this.last = null;
        this.now = null;
        this.tapTimeout = null;
        this.touchTimeout = null;
        this.longTapTimeout = null;
        this.swipeTimeout = null;
        this.x1 = this.x2 = this.y1 = this.y2 = null;
        this.preTapPosition = { x: null, y: null };
    };

    AlloyFinger.prototype = {
        start: function start(evt) {
            if (!evt.touches) return;
            this.now = Date.now();
            this.x1 = evt.touches[0].pageX;
            this.y1 = evt.touches[0].pageY;
            this.delta = this.now - (this.last || this.now);
            this.touchStart.dispatch(evt);
            if (this.preTapPosition.x !== null) {
                this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30;
            }
            this.preTapPosition.x = this.x1;
            this.preTapPosition.y = this.y1;
            this.last = this.now;
            var preV = this.preV,
                len = evt.touches.length;
            if (len > 1) {
                this._cancelLongTap();
                var v = { x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 };
                preV.x = v.x;
                preV.y = v.y;
                this.pinchStartLen = getLen(preV);
                this.multipointStart.dispatch(evt);
            }
            this.longTapTimeout = setTimeout(function () {
                this.longTap.dispatch(evt);
            }.bind(this), 750);
        },
        move: function move(evt) {
            if (!evt.touches) return;
            var preV = this.preV,
                len = evt.touches.length,
                currentX = evt.touches[0].pageX,
                currentY = evt.touches[0].pageY;
            this.isDoubleTap = false;
            if (len > 1) {
                var v = { x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY };

                if (preV.x !== null) {
                    if (this.pinchStartLen > 0) {
                        evt.scale = getLen(v) / this.pinchStartLen;
                        this.pinch.dispatch(evt);
                    }

                    evt.angle = getRotateAngle(v, preV);
                    this.rotate.dispatch(evt);
                }
                preV.x = v.x;
                preV.y = v.y;
            } else {
                if (this.x2 !== null) {
                    evt.deltaX = currentX - this.x2;
                    evt.deltaY = currentY - this.y2;
                } else {
                    evt.deltaX = 0;
                    evt.deltaY = 0;
                }
                this.pressMove.dispatch(evt);
            }

            this.touchMove.dispatch(evt);

            this._cancelLongTap();
            this.x2 = currentX;
            this.y2 = currentY;
            if (evt.touches.length > 1) {
                this._cancelLongTap();
                evt.preventDefault();
            }
        },
        end: function end(evt) {
            if (!evt.changedTouches) return;
            this._cancelLongTap();
            var self = this;
            if (evt.touches.length < 2) {
                this.multipointEnd.dispatch(evt);
            }
            this.touchEnd.dispatch(evt);
            //swipe
            if (this.x2 && Math.abs(this.x1 - this.x2) > 30 || this.y2 && Math.abs(this.preV.y - this.y2) > 30) {
                evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);
                this.swipeTimeout = setTimeout(function () {
                    self.swipe.dispatch(evt);
                }, 0);
            } else {
                this.tapTimeout = setTimeout(function () {
                    self.tap.dispatch(evt);
                    // trigger double tap immediately
                    if (self.isDoubleTap) {
                        self.doubleTap.dispatch(evt);
                        clearTimeout(self.touchTimeout);
                        self.isDoubleTap = false;
                    } else {
                        self.touchTimeout = setTimeout(function () {
                            self.singleTap.dispatch(evt);
                        }, 250);
                    }
                }, 0);
            }

            this.preV.x = 0;
            this.preV.y = 0;
            this.scale = 1;
            this.pinchStartLen = null;
            this.x1 = this.x2 = this.y1 = this.y2 = null;
        },
        cancel: function cancel(evt) {
            clearTimeout(this.touchTimeout);
            clearTimeout(this.tapTimeout);
            clearTimeout(this.longTapTimeout);
            clearTimeout(this.swipeTimeout);
            this.touchCancel.dispatch(evt);
        },
        _cancelLongTap: function _cancelLongTap() {
            clearTimeout(this.longTapTimeout);
        },
        _swipeDirection: function _swipeDirection(x1, x2, y1, y2) {
            return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? 'Left' : 'Right' : y1 - y2 > 0 ? 'Up' : 'Down';
        },

        on: function on(evt, handler) {
            if (this[evt]) {
                this[evt].add(handler);
            }
        },

        off: function off(evt, handler) {
            if (this[evt]) {
                this[evt].del(handler);
            }
        }
    };

    if (typeof module !== 'undefined' && ( false ? "undefined" : _typeof(exports)) === 'object') {
        module.exports = AlloyFinger;
    } else {
        window.AlloyFinger = AlloyFinger;
    }
})();

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* AlloyFinger v0.1.0 for Vue
 * By june01
 * Github: https://github.com/AlloyTeam/AlloyFinger
 */

;(function () {

  var AlloyFingerPlugin = {
    install: function install(Vue, options) {
      options = options || {};
      var AlloyFinger = window.AlloyFinger || options.AlloyFinger;
      var isVue2 = !!(Vue.version.substr(0, 1) == 2);

      if (!AlloyFinger) {
        throw new Error('you need include the AlloyFinger!');
      }

      var EVENTMAP = {
        'touch-start': 'touchStart',
        'touch-move': 'touchMove',
        'touch-end': 'touchEnd',
        'touch-cancel': 'touchCancel',
        'multipoint-start': 'multipointStart',
        'multipoint-end': 'multipointEnd',
        'tap': 'tap',
        'double-tap': 'doubleTap',
        'long-tap': 'longTap',
        'single-tap': 'singleTap',
        'rotate': 'rotate',
        'pinch': 'pinch',
        'press-move': 'pressMove',
        'swipe': 'swipe'
      };

      var CACHE = [];

      var directiveOpts = {};

      // get the index for elem in CACHE
      var getElemCacheIndex = function getElemCacheIndex(elem) {
        for (var i = 0, len = CACHE.length; i < len; i++) {
          if (CACHE[i].elem === elem) {
            return i;
          }
        }

        return null;
      };

      // do on or off handler
      var doOnOrOff = function doOnOrOff(cacheObj, options) {
        var eventName = options.eventName;
        var elem = options.elem;
        var func = options.func;
        var oldFunc = options.oldFunc;

        if (cacheObj && cacheObj.alloyFinger) {
          if (cacheObj.alloyFinger.off && oldFunc) cacheObj.alloyFinger.off(eventName, oldFunc);
          if (cacheObj.alloyFinger.on && func) cacheObj.alloyFinger.on(eventName, func);
        } else {
          options = {};
          options[eventName] = func;

          CACHE.push({
            elem: elem,
            alloyFinger: new AlloyFinger(elem, options)
          });
        }
      };

      // for bind the event
      var doBindEvent = function doBindEvent(elem, binding) {
        var func = binding.value;
        var oldFunc = binding.oldValue;
        var eventName = binding.arg;

        eventName = EVENTMAP[eventName];

        var cacheObj = CACHE[getElemCacheIndex(elem)];

        doOnOrOff(cacheObj, {
          elem: elem,
          func: func,
          oldFunc: oldFunc,
          eventName: eventName
        });
      };

      // for bind the event
      var doUnbindEvent = function doUnbindEvent(elem) {
        var index = getElemCacheIndex(elem);

        if (!isNaN(index)) {
          CACHE.splice(index, 1);
        }
      };

      if (isVue2) {
        directiveOpts = {
          bind: doBindEvent,
          update: doBindEvent,
          unbind: doUnbindEvent
        };
      } else {
        // vue1.xx
        directiveOpts = {
          update: function update(newValue, oldValue) {
            var binding = {
              value: newValue,
              arg: this.arg
            };

            var elem = this.el;

            doBindEvent.call(this, elem, binding);
          },
          unbind: function unbind() {
            var elem = this.el;

            doUnbindEvent.call(this, elem);
          }
        };
      }

      // definition
      Vue.directive('finger', directiveOpts);
    }
  };

  // export
  if (typeof module !== 'undefined' && ( false ? 'undefined' : _typeof(exports)) === 'object') {
    module.exports = AlloyFingerPlugin;
  } else {
    window.AlloyFingerVue = AlloyFingerPlugin;
  }
})();

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PinchSlider = undefined;

var _pinchSlider = __webpack_require__(0);

var _pinchSlider2 = _interopRequireDefault(_pinchSlider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

__webpack_require__(1);
exports.PinchSlider = _pinchSlider2.default;

/***/ }
/******/ ]);
});
//# sourceMappingURL=pinchSlider.min.js.map